function [new_alpha] = polynomial_div(S,N,K,lambdas,percentage)
% =========================================================================
%                  Polynomial Division Algorithm (Cristina)
% =========================================================================
% Description: the function obtains the polynomial generated by the highest
% eigenvalues of the laplacian that are set to be the roots of the original
% polynomial g_ker; it then divides the original polynomial by the reduces
% one to obtaine the filtered polynomial.
%% Input:
%   plot_kernels = flag
%   lambdas = the vector containing all the eigenvalues of the Laplacian
%   lambda_powers = all the powers of the eigenvalues
%   percentage = the threshold at which we want our kernels to go to zero
%% Output:
%   kernels = the new kernel functions
%   new_alpha = new alpa coefficients given by the costraint over the
%   eignevalues

%--provisional--
%I decide to take as the last lambdas all the roots of the polynomial
% percentage = degree;
% lambda_sym = param.lambda_sym;
%--------------
    lambdas_to_cut = lambdas(length(lambdas)-2*percentage+1:length(lambdas),1);

    %Transpose of Vandermonde matrix

    lambda_vand = zeros(percentage);
        for j = 1:percentage
            for i = 1:percentage
                lambda_vand(i,j) = lambdas_to_cut(i)^(percentage-j);
            end
        end
    gammas = null(lambda_vand);

    %Let's just choose a coefficients' combination
    my_gamma = gammas(:,1); %Since every kernel has to go to zero for certain 
                              %coefficients we can choose a gamma
                              %combinationa in such a way that when we
                              %divide the original polynomials by this
                              %subpolynomial we obtain S different
                              %reminders

% % %     %Updating the kernel coefficients
% % %     if (plot_kernels == 1)
% % %         g_ker = zeros(N, S);
% % %         %r = 0;
% % %         for i = 1 : S
% % %             for n = 1 :N
% % %                 p = 0;
% % %                 for l = 0 : K(i)-1
% % %                     p = p +  my_gamma(l + 1,1)*lambda_powers{n}(l + 1);
% % %                 end
% % %                 g_ker(n,i) = p;
% % %             end
% % %             %r = sum(param.K(1:i)) + i;
% % %         end
% % %     end

% % %     kernels = g_ker;
    new_alpha = my_gamma;

% % % figure()
% % % hold on
% % % for s = 1 : param.S
% % %     plot(lambda_sym,g_ker(:,s),num2str(color_matrix(s)));
% % % end
% % % hold off



